// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function pathSegments(req) {
  return new URL(req.url).pathname.split("/").filter(s => s !== "");
}

function text(body, statusOpt, headers) {
  let status = statusOpt !== undefined ? statusOpt : 200;
  let options = headers !== undefined ? ({
      status: status,
      headers: headers
    }) : ({
      status: status
    });
  return Promise.resolve(new Response(body, options));
}

function status(status$1, headers) {
  return text("", status$1, headers);
}

function json(data, statusOpt, headers) {
  let status = statusOpt !== undefined ? statusOpt : 200;
  let options = headers !== undefined ? ({
      status: status,
      headers: Primitive_option.some(new Headers(headers))
    }) : ({
      status: status
    });
  return Promise.resolve(Response.json(data, options));
}

function notFound() {
  return status(404, undefined);
}

function methodNotAllowed() {
  return status(405, undefined);
}

function get(req, handler) {
  let match = req.method;
  switch (match) {
    case "GET" :
    case "HEAD" :
      return handler(req);
    default:
      return status(405, undefined);
  }
}

function post(req, handler) {
  let match = req.method;
  if (match === "POST") {
    return handler(req);
  } else {
    return status(405, undefined);
  }
}

function put(req, handler) {
  let match = req.method;
  if (match === "PUT") {
    return handler(req);
  } else {
    return status(405, undefined);
  }
}

function patch(req, handler) {
  let match = req.method;
  if (match === "PATCH") {
    return handler(req);
  } else {
    return status(405, undefined);
  }
}

function $$delete(req, handler) {
  let match = req.method;
  if (match === "DELETE") {
    return handler(req);
  } else {
    return status(405, undefined);
  }
}

function serve(portOpt, handler) {
  let port = portOpt !== undefined ? portOpt : 3000;
  let server = Bun.serve({
    port: port,
    fetch: (request, _server) => handler(request)
  });
  let hostname = server.hostname;
  let portStr = server.port.toString();
  console.log(`server listening on http://` + hostname + `:` + portStr);
  return server;
}

function methodToString(method) {
  switch (method) {
    case "GET" :
      return "GET";
    case "HEAD" :
      return "HEAD";
    case "POST" :
      return "POST";
    case "PUT" :
      return "PUT";
    case "DELETE" :
      return "DELETE";
    case "CONNECT" :
      return "CONNECT";
    case "OPTIONS" :
      return "OPTIONS";
    case "TRACE" :
      return "TRACE";
    case "PATCH" :
      return "PATCH";
  }
}

function logger(handler) {
  return req => {
    let start = Date.now();
    let method = methodToString(req.method);
    let path = new URL(req.url).pathname;
    return handler(req).then(response => {
      let duration = Date.now() - start;
      let status = response.status.toString();
      console.log(method + ` ` + path + ` ` + status + ` ` + duration.toString() + `ms`);
      return response;
    });
  };
}

function html(body, statusOpt, headers) {
  let status = statusOpt !== undefined ? statusOpt : 200;
  let contentHeader = [
    "content-type",
    "text/html; charset=utf-8"
  ];
  let options_status = status;
  let options_headers = headers !== undefined ? Belt_Array.concatMany([
      [contentHeader],
      headers
    ]) : [contentHeader];
  let options = {
    status: options_status,
    headers: options_headers
  };
  return Promise.resolve(new Response(body, options));
}

export {
  pathSegments,
  text,
  status,
  json,
  notFound,
  methodNotAllowed,
  get,
  post,
  put,
  patch,
  $$delete,
  serve,
  methodToString,
  logger,
  html,
}
/* No side effect */
